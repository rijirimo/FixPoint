プログラムに関する説明を行う．

Problem3/test2.c に
Problem1/test2.c, Problem2/test2.c に含まれる関数がすべて含まれているため，
Problem3/test2.c に基づいて説明を行う．

9行目 line_count(char *)
は，ログファイルの行数を数える関数である．
ログファイルを読み込み形式で開き，一行ごとの読み込みを行いながら
行数をカウントする．

29行目 int server_count(char **, char **, int)
は，サーバ数をカウントする関数である．
まずログファイルの1行目をIPをtmp_IPに格納する．
その後，tmp_IPに格納されているIPアドレスと元のIPアドレスを格納している配列IP内のIPアドレスと
比較を行い，サーバ数をカウントしている．
重複を避けるための処理を38行目にて行っている．

48行目，59行目 mal(int), mal_double(int, int)
これらは，二次元配列のmallocを行うための関数である．

70行目 cpytime(char **, int n1, int n2, int *h, int *m, int *s)
は，n1番目およびn2番目の時刻を各配列 h, m, sに保存する関数である．
監視ログファイルの形式が決まっているため，時刻データから
時間，分，秒だけを抜き出す処理を行っている．

113行目 calc_fail(char **time, char **IP, char **ping, int line, int *flag, int N)
は，設問1,2のために作成した関数である．
1行目からサーバがタイムアウトしていないか精査を行っている．
flagでは，監視ログファイルの各行に対し，タイムアウトが起きたかどうかを管理している．
タイムアウトが起きた場合，flag は 1 を示す．

タイムアウトしているサーバがあった場合，
それ以降の行のサーバのpingを確認し，タイムアウトが起きていた場合countに1を加える．
countの値が 第3引数 N で与えられた値よりも大きい場合，故障とみなし，
サーバアドレス，故障開始日時，故障復旧日時を出力する．
タイムアウトしたサーバが最終行まで復旧しない場合，故障が復旧していない旨を出力する．

187行目 ave_ping(char **time, char **IP, char **ping, char **tmp_IP, int line, int IP_num, int m, int t)
は，直近m回の平均応答時間を計算し，それがtミリ秒を超えていた場合，過負荷状態となっていること，
過負荷状態である期間を出力する関数．


以下，main内の変数，配列について
今回，監視ログファイルの中身を
[時刻]，[IPアドレス]，[Ping]
として，それぞれを2次元配列で管理している．(time, IP, ping)
tmp_IPは，重複せずにIPアドレスを格納する配列である．

監視ログファイルの1行ごとを読み取り，dataで管理を行っている．